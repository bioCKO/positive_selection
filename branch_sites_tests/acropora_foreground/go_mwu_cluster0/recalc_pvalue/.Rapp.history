########################################### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_MBD.RData")#
ll=load("mbd_3mo.RData")#
head(k2o.r)#
head(o2k.r)#
rownames(k2o.r) = rownames(home.r)#
rownames(o2k.r) = rownames(home.r)#
CUT=2.5
#for both#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$stat)>CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$stat)>CUT];length(sig.genes2)#
sig.genes = append(sig.genes1, sig.genes2)
sig.genes=unique(sig.genes)#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions#
#
dat=vsds#
head(dat)#
dim(dat) #720 genes most differentially methylated by origin#
degs10<-rownames(dat)
a.vsd<-dat[,c(grep("OO",colnames(dat)), grep("OK",colnames(dat)))] #transplant site effect on Orpheus corals
a.vsd<-dat[,c(grep("OO",colnames(dat)), grep("OK",colnames(dat)))] #transplant site effect on Orpheus corals#
a.vsd.supp<-dat[,c(grep("KK",colnames(dat)),grep("KO",colnames(dat)))] #transplant site effect on Keppel corals
##################Some genes have insufficient variance for DFA in data subsets!...find those genes using loop below#
dframe=(a.vsd[degs10,])#
for(col in rownames(dframe))#
	{  min=min(dframe[col,])#
		max=max(dframe[col,])#
		if(min == max){print(col)}#
		}#
#
#If print out above, copy gene names below and run line to remove genes from analysis. #
#degs9=degs10[! degs10 %in% c("isogroup27486")]
#############now use appropriate dataset for analysis#
#
pcp=prcomp(t(a.vsd[degs10,]), retx=TRUE, center=TRUE, scale.=TRUE) #scale.=TRUE#
scores=pcp$x#
screeplot(pcp,bstick=T) # only 1st PC is non-random when using diff exp genes only; higher PCs non-random when using all data...#
#
# adegenet: finding clusters (even though we know what clusters we want) - choose 4 PCs and 2 groups#
clus=find.clusters(t(a.vsd[degs10,]),max.n.clus=15) #[degs10,]#
#Use clus$grp to rename to in2in and off2off -#
#Host#
colnames(a.vsd) #
clus$grp=c(substr(colnames(a.vsd), start=2,stop=2)) #se
clus$grp
pcp=prcomp(t(a.vsd[degs10,]), retx=TRUE, center=TRUE, scale.=TRUE) #scale.=TRUE
scores=pcp$x
screeplot(pcp,bstick=T) # only 1st PC is non-random when using diff exp genes only; higher PCs non-random when using all data...
clus=find.clusters(t(a.vsd[degs10,]),max.n.clus=15) #[degs10,]
colnames(a.vsd)
clus$grp=c(substr(colnames(a.vsd), start=2,stop=2)) #set the transplantation site as the groups
clus$grp
dp=dapc(t(a.vsd[degs10,]),clus$grp) #[degs10,]
quartz()#
scatter(dp,bg="white",scree.da=FALSE,legend=TRUE,solid=.4) #discriminant function for transplant
pred.sup<-predict.dapc(dp,newdata=(t(a.vsd.supp[degs10,]))) #skip IO11C for host b/c outlier sample in WGCNA
names(pred.sup)#
pred.sup$assign#
names(a.vsd.supp)
names(pred.sup)
colnames(a.vsd.supp)
#must create another dataframe structure in order to plot these predicted values#
test<-dp#
test$ind.coord<-pred.sup$ind.scores#
test$posterior<-pred.sup$posterior#
test$assign<-pred.sup$assign
clus$grp=c(substr(colnames(a.vsd), start=1,stop=2)) #set the transplantation site as the groups
clus$grp
#Use clus$grp to rename to in2in and off2off -#
#Host#
colnames(a.vsd) #
clus$grp=c(substr(colnames(a.vsd), start=1,stop=2)) #set the transplantation site as the groups#
# now lets build a discriminant function for these two groups:#
dp=dapc(t(a.vsd[degs10,]),clus$grp) #[degs10,]#
# HOST: PCs: 6, functions: 1. For two groups only one discriminant function is possible.#
# SYM: PCs: 6, functions: 1.#
#
quartz()#
scatter(dp,bg="white",scree.da=FALSE,legend=TRUE,solid=.4) #discriminant function for transp
dp=dapc(t(a.vsd[degs10,]),clus$grp) #[degs10,]
quartz()#
scatter(dp,bg="white",scree.da=FALSE,legend=TRUE,solid=.4) #discriminant function for transplant
pred.sup<-predict.dapc(dp,newdata=(t(a.vsd.supp[degs10,]))) #skip IO11C for host b/c outlier sample in WGCNA
names(pred.sup)#
pred.sup$assign#
colnames(a.vsd.supp)
#must create another dataframe structure in order to plot these predicted values#
test<-dp#
test$ind.coord<-pred.sup$ind.scores#
test$posterior<-pred.sup$posterior#
test$assign<-pred.sup$assign
test$grp<-as.factor(substr(colnames(a.vsd.supp), start =1, stop=2)) #make sure origin is same num as before: IN=2, OFF=1
quartz()#
#
scatter(test,bg="white",scree.da=FALSE,legend=TRUE,solid=.4,ylim=c(0,0.6),xlim=c(-4,4)) #
#adjust axes to correspond to prev
##############Build single plot with both#
a=data.frame(dp$ind.coord)#
a$treat=substr(rownames(a), start=1, stop=2)#
a=a[-grep('10_', rownames(a)),]#
mns=tapply(a$LD1, a$treat, mean)#
#plot discriminant analysis#
color.set=c('blue', 'cyan', 'orange', 'red')
a
t=pred.sup$ind.scores#
h=dp$ind.coord#
a=data.frame(rbind(t,h))#
head(a)
a
a$treat=substr(rownames(a), start=1, stop=2)
mns=tapply(a$LD1, a$treat, mean)#
#plot discriminant analysis#
color.set=c('blue', 'cyan', 'orange', 'red')#
quartz()#
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
library(ggplot2)
mns=tapply(a$LD1, a$treat, mean)#
#plot discriminant analysis#
color.set=c('blue', 'cyan', 'orange', 'red')#
quartz()#
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
rm(list=ls())
#--------------------- start here to do transplant figures ------------#
directory<-"/Users/grovesdixon/Desktop/redo"#
setwd(directory)#
ll=load("splitModels_GE.RData")#
load("GE_3mo.RData")#
gehome=home.r#
geo2k=o2k.r#
gek2o=k2o.r#
geokatk=okatk.r#
geokato=okato.r#
gevsd=vsd#
geconditions=conditions#
ll=load("splitModels_MBD.RData")#
ll=load("mbd_3mo.RData")#
conditions$sample=sub("_2m","",conditions$sample)#
# sshared=intersect(geconsditions$sample,conditions$sample)#
vsd=data.frame(vsd)#
colnames(vsd) = conditions$sample#
gevsd=data.frame(gevsd)#
colnames(gevsd) = geconditions$sample#
# load('splitModels_GE_MBD.RData')#
#
library(vegan)#
ad=adonis(t(gevsd)~origin+colony.id+transplant,data= geconditions,method="manhattan")#
labs=c("origin","colony.id","transplant","residuals")#
cols=c("skyblue","green2","coral","grey80")#
pie(ad$aov.tab$R2[1:4],labels=labs,col=cols,main="Gene expression")#
#
ad=adonis(t(vsd)~origin+colony.id+transplant,data= conditions,method="manhattan")#
quartz()#
pie(ad$aov.tab$R2[1:4],labels=labs,col=cols,main="Methylation")#
#
#------------------#
#
########## use this chunk for gene expression ##########
vsds=gevsd[abs(gehome$stat)>2.5,]#
coo=geconditions#
colnames(vsds) = coo$sample#
str(gehome)#
dim(vsds)#
########################################################
#
#### use this chunk for 3 month only methylation #######
vsds=vsd[abs(home.r$stat)>2.5,]#
coo=conditions#
str(vsds)#
dim(vsds)#
# GE: 1300 genes#
# MBD: 271 gene#
########################################################
#
#### use this chunk for 3 month only methylation #######
lnames=load("mbd_3_and_6mo.RData")#
dim(vsds)#
# ori.genes = rownames(vsd[abs(home.r$stat)>2.5,])#
# vsds=data.frame(vsd[rownames(vsd) %in% ori.genes,])#
# colnames(vsds) = conditions$sample#
# dim(vsds)#
# coo=conditions#
# # GE: 1300 genes#
# # MBD: 278 gene#
########################################################
library(vegan)#
#library(rgl)#
library(ape)#
library(ggplot2)#
library(MASS)#
#
#set up PCoA#
dd.pcoa=pcoa(vegdist(t(vsds),method="manhattan"))#
scores=dd.pcoa$vectors#
moo=apply(scores[grep("OO",coo$sample),],2,mean)#
mok=apply(scores[grep("OK",coo$sample),],2,mean)#
mkk=apply(scores[grep("KK",coo$sample),],2,mean)#
mko=apply(scores[grep("KO",coo$sample),],2,mean)#
#
# plotting PCoA#
margin=5#
pc1=1;pc2=2#
plot(scores[, pc1], scores[, pc2],xlab="PCo1",ylab="PCo2",mgp=c(2.3,1,0),xlim=c(min(scores[,1])-margin,max(scores[,1]+margin)),ylim=c(min(scores[,2])-margin,max(scores[,2]+margin)),cex=0.3,pch=19)#
#ordispider(scores[, c(pc1, pc2)],conditions$colony.id,col="skyblue")#
o2o=grep("OO", coo$sample)#
o2k=grep("OK", coo$sample)#
arrows(scores[o2o , pc1],scores[o2o, pc2] ,scores[o2k , pc1],scores[o2k, pc2],length=0.07)#
k2o=grep("KO", coo$sample)#
k2k=grep("KK", coo$sample)#
arrows(scores[k2k , pc1],scores[k2k, pc2] ,scores[k2o , pc1],scores[k2o, pc2],length=0.07)#
#ordihull(scores[, c(pc1, pc2)], coo$origin,draw="polygon",col="grey90",label=T,cex=0.8)#
#ordiellipse(scores[, c(pc1, pc2)], coo$origin,label=T,draw="polygon",col="grey90",cex=1)#
ordihull(scores[coo$origin=="K", c(pc1, pc2)],draw="polygon",col="skyblue",label=T,cex=0.8,groups=coo$origin)#
ordihull(scores[coo$origin=="O", c(pc1, pc2)],draw="polygon",col="pink",label=T,cex=0.8,groups=coo$origin)#
arrows(moo[pc1],moo[pc2],mok[pc1],mok[pc2],length=0.15,lwd=3,col="red")#
arrows(mkk[pc1],mkk[pc2],mko[pc1],mko[pc2],length=0.15,lwd=3,col="blue")#
# lnames=load('/Users/grovesdixon/git_Repositories/reciprocal_transplant_methylation/datasets/deseqObjects_GENEBODIES_promoter1000_200.Rdata')#
# lnames#
# vsd=data.frame(assay(meth.rld))#
# colnames(vsd) = sub("_2m", "", colnames(counts))#
# head(vsd)#
# dim(vsd)#
# head(traco)#
# sum(rownames(traco)==rownames(vsd))==nrow(vsd) #check rownames are same#
# vsds=vsd[abs(traco$stat>2.5),]#
# vsds=na.omit(vsds)#
# dim(vsds)
############ use this chunk for methylation #################
head(k2o.r)#
head(o2k.r)#
rownames(k2o.r) = rownames(home.r)#
rownames(o2k.r) = rownames(home.r)#
CUT=2.5#
# top=1000#
# #for transplant among keppel corals#
# sig.genes = rownames(k2o.r)[abs(k2o.r$stat)>2.2];length(sig.genes)#
# sig.genes = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
#
# #for transplant among orpheus corals#
# sig.genes = rownames(o2k.r)[abs(o2k.r$stat)>3.2];length(sig.genes)#
# sig.genes = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
#for both#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$stat)>CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$stat)>CUT];length(sig.genes2)#
sig.genes = append(sig.genes1, sig.genes2)#
#
#to use top set significant genes:#
# sig.genes1 = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
# sig.genes2 = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
# sig.genes = append(sig.genes1, sig.genes2)#
# length(sig.genes)#
sig.genes=unique(sig.genes)#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions
str(vsds)#
dim(vsds)#
##set of discriminant analysis#
lin = data.frame(t(vsds))#
dim(lin)#
ori=substr(rownames(lin), start=1, stop=1)#
trans=substr(rownames(lin), start=2, stop=2)#
treat=substr(rownames(lin), start=1, stop=2)#
# hometags=c('OO', 'KK')#
# home=treat#
# home[!home %in% hometags]<-NA#
# lin$ori=ori#
# lda <- lda(ori ~ ., data=lin)#
lin$trans=trans#
lda <- lda(trans ~ ., data=lin)#
lda.vals <- predict(lda)#
# ldahist(data = lda.vals$x[,1], g=treat)#
lda.res = data.frame(lda.vals$x, treat)#
num=substr(rownames(lda.res), start=3, stop=5)#
lda.res=lda.res[!num=='10',]#
#
mns=tapply(lda.res$LD1, lda.res$treat, mean)#
#
#plot discriminant analysis
#plot discriminant analysis#
color.set=c('blue', 'cyan', 'orange', 'red')#
quartz()#
ggplot(data=lda.res, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set) # + geom_vline(xintercept=mns, color=color.set)
############ use this chunk for methylation #################
head(k2o.r)#
head(o2k.r)#
rownames(k2o.r) = rownames(home.r)#
rownames(o2k.r) = rownames(home.r)#
CUT=2.5#
# top=1000#
# #for transplant among keppel corals#
# sig.genes = rownames(k2o.r)[abs(k2o.r$stat)>2.2];length(sig.genes)#
# sig.genes = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
#
# #for transplant among orpheus corals#
# sig.genes = rownames(o2k.r)[abs(o2k.r$stat)>3.2];length(sig.genes)#
# sig.genes = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
#for both#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$stat)>CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$stat)>CUT];length(sig.genes2)#
sig.genes = append(sig.genes1, sig.genes2)#
#
#to use top set significant genes:#
# sig.genes1 = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
# sig.genes2 = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
# sig.genes = append(sig.genes1, sig.genes2)#
# length(sig.genes)#
sig.genes=unique(sig.genes)#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions
lda.res
lda.res=lda.res[!num=='10',]
num=substr(rownames(lda.res), start=3, stop=5)
##set of discriminant analysis#
lin = data.frame(t(vsds))#
dim(lin)#
ori=substr(rownames(lin), start=1, stop=1)#
trans=substr(rownames(lin), start=2, stop=2)#
treat=substr(rownames(lin), start=1, stop=2)#
# hometags=c('OO', 'KK')#
# home=treat#
# home[!home %in% hometags]<-NA#
# lin$ori=ori#
# lda <- lda(ori ~ ., data=lin)#
lin$trans=trans#
lda <- lda(trans ~ ., data=lin)#
lda.vals <- predict(lda)#
# ldahist(data = lda.vals$x[,1], g=treat)#
lda.res = data.frame(lda.vals$x, treat)#
num=substr(rownames(lda.res), start=3, stop=5)#
lda.res=lda.res[!num=='10',]
mns=tapply(lda.res$LD1, lda.res$treat, mean)#
#
#plot discriminant analysis#
color.set=c('blue', 'cyan', 'orange', 'red')#
quartz()#
ggplot(data=lda.res, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set) # + geom_vline(xintercept=mns, color=color.set)
ggplot(data=lda.res, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set) # + geom_vline(xintercept=mns, color=color.set)
#--------gather the mbd discim data ------------#
lda.res$Colony.ID = rownames(lda.res)#
head(lda.res)#
x = merge(traits, lda.res, by='Colony.ID', all.x=T)#
x=x[order(x$Colony.ID),]#
sum(x$Colony.ID == traits$Colony.ID)==nrow(traits)#
traits$mbd.LD1=x$LD1#
#------------------------------------------------#
head(traits)#
#plot correlation with gain#
CEX=2#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#KO samples#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)
lnames=load('bayRT_rlog_conditions_traits.RData')
#--------gather the mbd discim data ------------#
lda.res$Colony.ID = rownames(lda.res)#
head(lda.res)#
x = merge(traits, lda.res, by='Colony.ID', all.x=T)#
x=x[order(x$Colony.ID),]#
sum(x$Colony.ID == traits$Colony.ID)==nrow(traits)#
traits$mbd.LD1=x$LD1#
#------------------------------------------------
head(traits)#
#plot correlation with gain#
CEX=2#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#KO samples#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)
plot(GAIN~mbd.LD1, data=traits)
traits
############# use this chunk for methylation #################
head(k2o.r)#
head(o2k.r)#
rownames(k2o.r) = rownames(home.r)#
rownames(o2k.r) = rownames(home.r)#
CUT=2.5#
# top=1000#
# #for transplant among keppel corals#
# sig.genes = rownames(k2o.r)[abs(k2o.r$stat)>2.2];length(sig.genes)#
# sig.genes = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
#
# #for transplant among orpheus corals#
# sig.genes = rownames(o2k.r)[abs(o2k.r$stat)>3.2];length(sig.genes)#
# sig.genes = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
#for both#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$stat)>CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$stat)>CUT];length(sig.genes2)#
sig.genes = append(sig.genes1, sig.genes2)#
#
#to use top set significant genes:#
# sig.genes1 = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
# sig.genes2 = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
# sig.genes = append(sig.genes1, sig.genes2)#
# length(sig.genes)#
sig.genes=unique(sig.genes)#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions
conditions
head(vsds)
colnames(vsds)=sub("_2m", "", colnames(vsds))
head(vsds)
str(vsds)#
dim(vsds)#
##set of discriminant analysis#
lin = data.frame(t(vsds))#
dim(lin)#
ori=substr(rownames(lin), start=1, stop=1)#
trans=substr(rownames(lin), start=2, stop=2)#
treat=substr(rownames(lin), start=1, stop=2)#
# hometags=c('OO', 'KK')#
# home=treat#
# home[!home %in% hometags]<-NA#
# lin$ori=ori#
# lda <- lda(ori ~ ., data=lin)#
lin$trans=trans#
lda <- lda(trans ~ ., data=lin)#
lda.vals <- predict(lda)#
# ldahist(data = lda.vals$x[,1], g=treat)#
lda.res = data.frame(lda.vals$x, treat)#
num=substr(rownames(lda.res), start=3, stop=5)#
lda.res=lda.res[!num=='10',]#
#
mns=tapply(lda.res$LD1, lda.res$treat, mean)#
#
#plot discriminant analysis#
color.set=c('blue', 'cyan', 'orange', 'red')#
quartz()#
ggplot(data=lda.res, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set) # + geom_vline(xintercept=mns, color=color.set)
#--------gather the mbd discim data ------------#
lda.res$Colony.ID = rownames(lda.res)#
head(lda.res)#
x = merge(traits, lda.res, by='Colony.ID', all.x=T)#
x=x[order(x$Colony.ID),]#
sum(x$Colony.ID == traits$Colony.ID)==nrow(traits)#
traits$mbd.LD1=x$LD1#
#------------------------------------------------#
head(traits)#
#plot correlation with gain#
CEX=2#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#KO samples#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)
#overlay mortality#
#get mortality data#
lnames=load('~/git_Repositories/reciprocal_transplant_methylation/datasets/wgcnaInitialize_p1000_200_iterate_mnCount10.Rdata')#
head(traitData)#
z=traitData[-grep('3m', rownames(traitData)),]#
x=data.frame(z$Colony.ID, z$mortality)#
colnames(x) = c('Colony.ID', 'mortality')#
head(x)#
m=merge(traits, x, by = 'Colony.ID', all.x=T)#
sum(m$Colony.ID==traits$Colony.ID)==nrow(traits)#
traits$mortality = m$mortality#
#plot death points#
head(traits)#
dead=traits[traits$mortality==1 & !is.na(traits$mortality),]#
points(GAIN~mbd.LD1, data=dead, pch=4, cex=2.5)#
traits$geno=paste(traits$ori, traits$num, sep='')#
dead=traits[traits$mortality==1 & !is.na(traits$mortality),]#
dead.genos=dead$geno#
died=traits[traits$geno %in% dead.genos,]
points(GAIN~mbd.LD1, data=died, pch=4, cex=2.5)
head(traits)
m=traits[traits$mortality==1,]
m
m=traits[traits$mortality==1 & !is.na(traits$mortality),]
m
abline(v=m$mbd.LD1)
mcols=paste(m$ori, m$tra, sep="")
mcols
mcols
mcols[mcols=='KK']<='blue'#
mcols[mcols=='KO']<='cyan'#
mcols[mcols=='OK']<='orange'#
mcols[mcols=='OO']<='red'
mcols=paste(m$ori, m$tra, sep="")
mcols[mcols=='KK']<-'blue'#
mcols[mcols=='KO']<-'cyan'#
mcols[mcols=='OK']<-'orange'#
mcols[mcols=='OO']<-'red'
mcols
abline(v=m$mbd.LD1, col=mcols)
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.#
setwd("~/git_Repositories/positive_selection/branch_sites_tests/acropora_foreground/go_mwu")#
#
# Edit these to match your data file names: #
input="branch_site_LRT_results_for_GOmwu.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).#
goAnnotations="adig_go_final.tsv" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.#
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml#
goDivision="BP" # either MF, or BP, or CC#
source("~/git_Repositories/positive_selection/scripts/gomwu.functions.R")
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.3, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.2, # FDR cutoff to print in regular (not italic) font.#
	level3=0.1, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many cate
#upload the output merged GO results linking each gene with it's merged GO terms#
mGo = paste(goDivision, input, sep = "_")#
godf=read.table(mGo, header = T, sep = "\t")
head(mGo)
head(godf)
head(resName)
#look at results file giving the stats for each GO term#
resName = paste(paste('MWU', goDivision, sep = "_"), input, sep = "_")#
res=read.table(resName, header = T)#
res=res[order(res$pval),]#
head(res, n=20)
resName
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input')
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input.csv')
head(hres)
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input.csv', header = T)
sigh=hres[hres$p.adj < CUT,]
head(sigh)
res=res[res$name %in% sigh,]
head(res)
head(res, n=20)
#look at results file giving the stats for each GO term#
resName = paste(paste('MWU', goDivision, sep = "_"), input, sep = "_")#
res=read.table(resName, header = T)#
res=res[order(res$pval),]#
head(res, n=20)
res=res[res$name %in% sigh$name,]
head(res)
?padjust
?p.adjust
res$p.readj=p.adjust(res$pval, method='BH')
res=res[order(res$pval),]
head(res, n=20)
CUT=0.05#
sigh=hres[hres$p.adj < CUT,]#
head(sigh)#
res=res[res$name %in% sigh$name,]#
head(res)#
res$p.readj=p.adjust(res$pval, method='BH')#
res=res[order(res$pval),]#
head(res, n=20)
#look at results file giving the stats for each GO term#
resName = paste(paste('MWU', goDivision, sep = "_"), input, sep = "_")#
res=read.table(resName, header = T)#
res=res[order(res$pval),]#
head(res, n=20)#
#
#------------- upload results from the Hemond enrichment test ----------------#
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input.csv', header = T)#
head(hres)#
CUT=0.05
sigh=hres[hres$p.adj < CUT,]#
head(sigh)
res2=res2[res2$name %in% sigh$name,]
res2=res[res$name %in% sigh$name,]
head(res2)
dim(res2)
dim(sigh)
#------------- upload results from the Hemond enrichment test ----------------#
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input.csv', header = T)#
head(hres)#
CUT=0.1#
sigh=hres[hres$p.adj < CUT,]#
head(sigh)#
dim(sigh)
#------------- upload results from the Hemond enrichment test ----------------#
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input.csv', header = T)#
head(hres)#
CUT=0.05#
sigh=hres[hres$p.adj < CUT,]#
head(sigh)#
dim(sigh)#
res2=res[res$name %in% sigh$name,]#
dim(res2)#
head(res2)
dim(res2)
res2$p.readj=p.adjust(res2$pval, method='BH')
res2=res2[order(res2$pval),]#
head(res2, n=20)
#------------- upload results from the Hemond enrichment test ----------------#
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input.csv', header = T)#
head(hres)#
CUT=0.1#
sigh=hres[hres$p.adj < CUT,]#
head(sigh)#
dim(sigh)#
res2=res[res$name %in% sigh$name,]#
head(res2)#
dim(res2)#
res2$p.readj=p.adjust(res2$pval, method='BH')#
res2=res2[order(res2$pval),]#
head(res2, n=20)
#look at results file giving the stats for each GO term#
resName = paste(paste('MWU', goDivision, sep = "_"), input, sep = "_")#
res=read.table(resName, header = T)#
res=res[order(res$pval),]#
head(res, n=20)
#------------- upload results from the Hemond enrichment test ----------------#
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input.csv', header = T)#
head(hres)#
CUT=0.1#
sigh=hres[hres$p.adj < CUT,]#
head(sigh)#
dim(sigh)
res2=res[res$name %in% sigh$name,]#
head(res2)#
dim(res2)
res2$p.readj=p.adjust(res2$pval, method='BH')
res2=res2[order(res2$pval),]#
head(res2, n=20)
#------------- upload results from the Hemond enrichment test ----------------#
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input.csv', header = T)#
head(hres)
hres=hres[order(hres$pval),]
head(hres, n=30)
CUT=0.1#
sigh=hres[hres$p.adj < CUT,]#
sigh
#------------- upload results from the Hemond enrichment test ----------------#
hres=read.table('~/git_Repositories/positive_selection/Hemond_data/go_mwu/MWU_BP_hemond_position_UNSIGNED_goMWU_input.csv', header = T)#
head(hres)#
hres=hres[order(hres$pval),]#
head(hres, n=30)#
CUT=0.05#
sigh=hres[hres$pval < CUT,]#
sigh
dim(sigh)#
res2=res[res$name %in% sigh$name,]#
head(res2)#
dim(res2)#
res2$p.readj=p.adjust(res2$pval, method='BH')#
res2=res2[order(res2$pval),]#
head(res2, n=20)
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.36, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.35, # FDR cutoff to print in regular (not italic) font.#
	level3=0.1, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there a
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.36, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.35, # FDR cutoff to print in regular (not italic) font.#
	level3=0.1, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there a
head(res2)
setwd("~/git_Repositories/positive_selection/branch_sites_tests/acropora_foreground/go_mwu/recalc_pvalue")
head(res2)
res2$p.adj=res2$p.readj#
res2$p.readj<-NULL
write.table(res2, file= resName)
# replot results for subsetted analysis#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.1, # FDR cutoff to print in regular (not italic) font.#
	level3=0.12, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.
getwd()
# replot results for subsetted analysis#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.1, # FDR cutoff to print in regular (not italic) font.#
	level3=0.12, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.1, # FDR cutoff to print in regular (not italic) font.#
	level3=0.12, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too m
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.1, # FDR cutoff to print in regular (not italic) font.#
	level3=0.12, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too m
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.011, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.1, # FDR cutoff to print in regular (not italic) font.#
	level3=0.05, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too ma
head(res2, n=20)
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.36, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.01, # FDR cutoff to print in regular (not italic) font.#
	level3=0.05, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.36, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.01, # FDR cutoff to print in regular (not italic) font.#
	level3=0.05, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too man
head(res, n=20)
head(res2, n=20)
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.4, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.01, # FDR cutoff to print in regular (not italic) font.#
	level3=0.05, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.
head(res2, n=20)
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.1,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.05, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.1, # FDR cutoff to print in regular (not italic) font.#
	level3=0.05, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are t
